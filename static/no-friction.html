<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <title>0friction</title>
    <script>
      var canvas, ctx;
      var config = {
        player: {
          width: 50,
          height: 50,
          screenDownPct: 0.85
        },
        enemy: {
          height: 40,
          width: 40,
          ySpeed: 0.27,
          xSpeed: 0
        },
        enemyCleanThreshold: 60
      };
      var state;
      function cleanEnemies() {
        if (state.enemies.length > config.enemyCleanThreshold) {
          console.log("Cleaning enemies...");
          state.enemies.forEach(function (enemy, i) {
            if (enemy === null) {
              state.enemies.splice(enemy, 1);
            }
          });
        }
      }
      function secondLogicTick(delta) {
        // delta is between 0 and 1.999 (called multiple times if bigger)
        // so delta isn't more than a *second*
        if (state.gameOver) return;
        if (state.enemiesPerSecond < config.enemy.enemiesPerSecondMax) {
          state.enemiesPerSecond += config.enemy.enemiesPerSecondStep * delta;
        }
        if (state.spawnNew && (Math.random() < (delta * state.enemiesPerSecond))) {
          state.enemies.push({
            x: Math.random(),
            y: 0,
            speedFactor: (Math.random() * 0.2) + 0.9 // 0.9 - 1.1
          })
        }
      }
      var lastSecondLogicTick;
      function secondLogicTickLoop() {
        if (lastSecondLogicTick) {
          var tickTime = Date.now() - lastSecondLogicTick;
          lastSecondLogicTick = Date.now();
          if (tickTime > 2000) {
            var wholeTicks = Math.floor(tickTime / 1000);
            for (var i = 0; i < wholeTicks; i++) {
              secondLogicTick(1);
            }
            secondLogicTick((tickTime % 1000) / 1000);
          } else {
            secondLogicTick(tickTime / 1000);
          }
        }
        lastSecondLogicTick = Date.now();
      }
      setInterval(secondLogicTickLoop, 35);
      function tickLogic(delta) {
        state.enemies.forEach(function (enemy, i) {
          if (enemy === null) return;
          enemy.y += config.enemy.ySpeed * enemy.speedFactor * delta;
          //enemy.x += config.enemy.xSpeed * enemy.speedFactor;
        });
        // delta is how many seconds since last call
        if (state.leftPressed) {
          state.player.xv -= config.player.xvPerSecond;
        } else if (state.rightPressed) {
          state.player.xv += config.player.xvPerSecond;
        } else if (state.player.xv > 0) {
          state.player.xv -= config.player.xvFriction;
          if (state.player.xv < 0) state.player.xv = 0;
        } else if (state.player.xv < 0) {
          state.player.xv += config.player.xvFriction;
          if (state.player.xv > 0) state.player.xv = 0;
        }
        if (state.player.leftPressed || state.player.rightPressed) {
          if ((state.player.xv) > 0 && (player.xv < config.player.minXv)) state.player.xv = config.player.minXv;
          if ((state.player.xv) < 0 && (player.xv > -config.player.minXv)) state.player.xv = -config.player.minXv;
        }
        
        // out of bounds?
        if (state.player.x > ((canvas.width / 2) - config.player.width)) {
          state.player.x = (canvas.width / 2) - config.player.width;
          state.player.xv = -state.player.xv;
          state.player.xv += config.player.bouncePenalty;
        }
        if (state.player.x < -(canvas.width / 2)) {
          state.player.x = -(canvas.width / 2);
          state.player.xv = -state.player.xv;
          state.player.xv -= config.player.bouncePenalty;
        }
        if (state.player.xv > config.player.xvMax) state.player.xv = config.player.xvMax;
        if (state.player.xv < -config.player.xvMax) state.player.xv = -config.player.xvMax
        
        if (state.player.canMove) {
          state.player.x += config.player.speedFactor * state.player.xv * delta;
        }
        
        // touching an enemy?
        var scoreChanged = false;
        state.enemies.forEach(function (enemy, i) {
          if (enemy === null) return;
          if (enemy.y > (1 + (config.enemy.height / canvas.height))) {
            state.enemies[i] = null;
            state.score++;
            scoreChanged = true;
            if (state.enemies.length > config.enemyCleanThreshold) requestIdleCallback(cleanEnemies, {timeout: 30000});
            return;
          }
          if (!state.player.immune) {
            var enemyY1 = enemy.y * canvas.height;
            var enemyY2 = enemyY1 + config.enemy.height;
            var enemyX1 = enemy.x * canvas.width;
            var enemyX2 = enemyX1 + config.enemy.width;
            var playerY1 = canvas.height * config.player.screenDownPct;
            var playerY2 = playerY1 + config.player.height;
            var playerX1 = state.player.x + canvas.width / 2;
            var playerX2 = playerX1 + config.player.width;
            if (enemyX1 < playerX2 &&
                enemyX2 > playerX1 &&
                enemyY1 < playerY2 &&
                enemyY2 > playerY1) {
              state.gameOver = true;
              gameOver();
            }
          }
        });
        if (scoreChanged) {
          document.getElementById("score").innerText = state.score.toString();
        }
      }
      function renderLoop(ts) {
        requestAnimationFrame(renderLoop);
        if (state.gameOver) return;
        if (!state.lastRender) {
          state.lastRender = ts;
        } else {
          tickLogic(Math.min((ts - state.lastRender) / 1000, 0.33)); // cap delta at 0.33
          state.lastRender = ts;
        }
        
        ctx.fillStyle = "white";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "blue";
        ctx.fillRect(
          state.player.x + canvas.width / 2, // x
          canvas.height * config.player.screenDownPct, // y
          config.player.width, // width
          config.player.height // height
        );
        ctx.fillStyle = "red";
        state.enemies.forEach(function (enemy) {
          if (enemy === null) return;
          ctx.fillRect(
            enemy.x * canvas.width, // percent of width
            enemy.y * canvas.height, // percent of height
            config.enemy.width, // width
            config.enemy.height // height
          );
        });
      }
      function gameOver() {
        document.getElementById("try-again").disabled = false;
        document.getElementById("game-over-title").innerText = "Game over...";
        document.getElementById("try-again").innerText = "Try again?";
        document.getElementById("game-over-total-score").style.display = "block";
        document.getElementById("total-score").innerText = state.score;
        var oldHs = parseInt(localStorage["high-score"], 10);
        if (state.score > oldHs) {
          localStorage["high-score"] = state.score.toString();
          document.getElementById("high-score").innerText = state.score.toString();
        }
        document.body.classList.add("game-over");
      }
      function setup() {
        state = {
          player: {
            x: 0,
            xv: 0,
            immune: false,
            canMove: true
          },
          enemies: [],
          lastRender: null,
          leftPressed: false,
          rightPressed: false,
          gameOver: false,
          spawnNew: true,
          score: 0
        };
        config.player.xvMax = canvas.width *              5;
        config.player.speedFactor = 0.2;
        config.player.bouncePenalty = canvas.width *      0;
        config.player.xvPerSecond = canvas.width *        0.18;
        config.player.minXv = 0;
        config.player.xvFriction = canvas.width *         0;
        state.enemiesPerSecond = canvas.width *           0.0040;
        config.enemy.enemiesPerSecondMax = canvas.width * 0.0085;
        config.enemy.enemiesPerSecondStep = (config.enemy.enemiesPerSecondMax - state.enemiesPerSecond) / 20;
        
        state.leftPressed = false;
        state.rightPressed = false;
      }
      window.addEventListener("load", function () {
        canvas = document.getElementById("game-canvas");
        //canvas.width = (window.innerWidth - 30);
        document.getElementById("game-over-text").style.height = getComputedStyle(document.getElementById("game-canvas")).height;
        document.getElementById("game-over-text").style.width = getComputedStyle(document.getElementById("game-canvas")).width;
        ctx = canvas.getContext("2d", {
          alpha: false,
          desynchronized: true,
        });
        setup();
        state.gameOver = true;
        renderLoop();
        document.getElementById("try-again").addEventListener("click", function () {
          document.getElementById("try-again").disabled = true;
          document.body.classList.remove("game-over");
          document.getElementById("score").innerText = "0";
          setup();
        });
        if (!localStorage["high-score"]) {
          localStorage["high-score"] = "0";
        } else {
          document.getElementById("high-score").innerText = localStorage["high-score"];
        }
      });
      var leftKeys = ["KeyA", "ArrowLeft"]; // A is in the same place on QWERTY and DVORAK
      var rightKeys = ["KeyD", "KeyE", "ArrowRight"]; // E is where D is on DVORAK
      window.addEventListener("keydown", function (e) {
        if (leftKeys.indexOf(e.code) > -1) {
          state.leftPressed = true;
        }
        if (rightKeys.indexOf(e.code) > -1) {
          state.rightPressed = true;
        }
      });
      window.addEventListener("keyup", function (e) {
        if (leftKeys.indexOf(e.code) > -1) {
          state.leftPressed = false;
        }
        if (rightKeys.indexOf(e.code) > -1) {
          state.rightPressed = false;
        }
      });
    </script>
    <style>
      body {
        font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen-Sans,Ubuntu,Cantarell,"Helvetica Neue",sans-serif;
      }
      div {
        margin: 0;
        padding: 0;
      }
      #game-canvas {
        transition-duration: 0.5s;
        transition-property: background-color, opacity;
        transition-timing-function: ease-in-out;
        border: 1px solid black;
        position: absolute;
      }
      #game-over-text {
        display: none;
        text-align: center;
        vertical-align: middle;
        position: absolute;
      }
      #game-over-text h2 {

      }
      .game-over #game-canvas {
        opacity: 0.3;
      }
      .game-over #game-over-text {
        display: block;
        z-index: 0;
        padding-top: 1em;
        background: #c4c7d64d;
      }
      h1 {
        display: inline;
      }
      #score-container {
        font-weight: bold;
        font-size: 1.33em;
      }
    </style>
  </head>
  <body class="game-over">
    <h1>0friction</h1> <span id="score-container"> | Score: <span id="score">0</span> | High score: <span id="high-score">0</span></span>
    <div>
      Use A/D or arrow keys to move left and right. Avoid the red enemies. There is no friction so the controls will feel *really* slippery. <br> Want a bouns challenge? Don't press the key to go left. <br> By <a href="https://smitop.com">Smitop</a>.
    </div>
    <div>
      <canvas width="800" height="500" id="game-canvas"></canvas>
      <div id="game-over-text">
        <h2 id="game-over-title">Play</h2>
        <div id="game-over-total-score" style="display: none;">Total score: <span id="total-score">10</span></div>
        <div>
          <button id="try-again">Start</button>
        </div>
      </div>
    </div>
  </body>
</html>
